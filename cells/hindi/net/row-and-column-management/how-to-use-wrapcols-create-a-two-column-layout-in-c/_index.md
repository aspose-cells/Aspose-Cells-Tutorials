---
category: general
date: 2026-02-15
description: WRAPCOLS का उपयोग करके दो कॉलम लेआउट बनाना, फ़ॉर्मूला जोड़ना और C# वर्कशीट्स
  में सीक्वेंस एरे जनरेट करना – चरण‑दर‑चरण गाइड।
draft: false
keywords:
- how to use wrapcols
- create two column layout
- how to add formula
- how to create columns
- generate sequence array
language: hi
og_description: WRAPCOLS का उपयोग करके दो‑कॉलम लेआउट बनाना, फॉर्मूले जोड़ना और C#
  वर्कशीट में सीक्वेंस एरे जनरेट करना – पूर्ण गाइड।
og_title: 'WRAPCOLS का उपयोग कैसे करें: C# में दो‑स्तंभ लेआउट'
tags:
- CSharp
- ExcelAutomation
- WorksheetFormula
title: 'WRAPCOLS का उपयोग कैसे करें: C# में दो‑स्तंभ लेआउट बनाएं'
url: /hi/net/row-and-column-management/how-to-use-wrapcols-create-a-two-column-layout-in-c/
---

{{< blocks/products/pf/main-wrap-class >}}
{{< blocks/products/pf/main-container >}}
{{< blocks/products/pf/tutorial-page-section >}}

# WRAPCOLS का उपयोग कैसे करें: C# में दो‑कॉलम लेआउट बनाएं

क्या आप कभी सोचते रहे हैं **WRAPCOLS का उपयोग कैसे करें** जब आपको Excel‑स्टाइल वर्कशीट में जल्दी से दो‑कॉलम दृश्य चाहिए? आप अकेले नहीं हैं। कई डेवलपर्स को यह समस्या आती है जब वे उत्पन्न सूची को साफ़ कॉलम में बाँटने की कोशिश करते हैं बिना प्रत्येक सेल के लिए लूप लिखे। अच्छी खबर? `WRAPCOLS` फ़ंक्शन के साथ आप एक ही फ़ॉर्मूला `A1` में डाल सकते हैं और Excel (या कोई संगत इंजन) बाकी काम कर देगा।

इस ट्यूटोरियल में हम **फ़ॉर्मूला कैसे जोड़ें** जो **दो‑कॉलम लेआउट बनाता है**, आपको **डायनामिक रूप से कॉलम कैसे बनाएं** दिखाएंगे, और यहाँ तक कि **सीक्वेंस एरे** मानों को तुरंत जेनरेट करेंगे। अंत तक आपके पास एक पूरी तरह चलने योग्य C# स्निपेट होगा जिसे आप अपने प्रोजेक्ट में पेस्ट कर सकते हैं, चला सकते हैं, और तुरंत एक साफ़ दो‑कॉलम ब्लॉक देख सकते हैं।

## आप क्या सीखेंगे

- `WRAPCOLS` का उद्देश्य और यह मैन्युअल लूपिंग की तुलना में क्यों बेहतर विकल्प है।  
- C# का उपयोग करके वर्कशीट सेल में **फ़ॉर्मूला कैसे जोड़ें**।  
- `SEQUENCE` के साथ सीक्वेंस एरे कैसे जेनरेट करें और उसे `WRAPCOLS` में पास करें।  
- शीट को पुनः गणना करने के टिप्स ताकि फ़ॉर्मूला तुरंत लागू हो जाए।  
- एज‑केस हैंडलिंग (जैसे, खाली वर्कशीट, कस्टम कॉलम काउंट)।  

एक मानक Excel‑प्रोसेसिंग पैकेज के अलावा कोई बाहरी लाइब्रेरी आवश्यक नहीं है – हम **ClosedXML** का उपयोग करेंगे क्योंकि इसका API सरल है, लेकिन ये अवधारणाएँ EPPlus, SpreadsheetGear, या यहाँ तक कि Google Sheets के API में भी लागू होती हैं।

## पूर्वापेक्षाएँ

- .NET 6.0 या बाद का संस्करण (कोड .NET Core और .NET Framework दोनों पर कंपाइल होता है)।  
- **ClosedXML** का रेफ़रेंस (`dotnet add package ClosedXML`)।  
- बुनियादी C# ज्ञान – आपको `using` स्टेटमेंट्स और ऑब्जेक्ट इनिशियलाइज़ेशन में सहज होना चाहिए।  

यदि आपके पास पहले से ही वर्कबुक खुला है, तो आप फ़ाइल‑क्रिएशन भाग को छोड़ कर सीधे फ़ॉर्मूला सेक्शन पर जा सकते हैं।

## चरण 1: वर्कशीट सेट अप करें (कॉलम कैसे बनाएं)

सबसे पहले हमें काम करने के लिए एक `Worksheet` ऑब्जेक्ट चाहिए। ClosedXML में आप इसे `XLWorkbook` से प्राप्त करते हैं। नीचे दिया गया स्निपेट एक नया वर्कबुक बनाता है, *Demo* नाम की शीट जोड़ता है, और स्पष्टता के लिए `worksheet` नाम का रेफ़रेंस लेता है।

```csharp
using ClosedXML.Excel;

namespace WrapColsDemo
{
    class Program
    {
        static void Main()
        {
            // Create a fresh workbook and add a worksheet named "Demo"
            using var workbook = new XLWorkbook();
            var ws = workbook.Worksheets.Add("Demo");

            // Rename for clarity – this is the worksheet we’ll manipulate
            var worksheet = ws;   // <-- same object, just a clearer name

            // --------------------------------------------------------------
            // Next step: write the WRAPCOLS formula
            // --------------------------------------------------------------
```

> **नाम बदलने का कारण?**  
> वेरिएबल नाम को छोटा (`worksheet`) रखने से बाद का कोड पढ़ने में आसान रहता है, विशेषकर जब आप कई ऑपरेशन्स को चेन करते हैं। यह अधिकांश डॉक्यूमेंटेशन में देखे जाने वाले नेमिंग स्टाइल को भी दर्शाता है, जिससे Cognitive Load कम होता है।

## चरण 2: फ़ॉर्मूला लिखें (फ़ॉर्मूला कैसे जोड़ें + सीक्वेंस एरे जेनरेट करें)

अब जादू की लाइन आती है। हम **A1** सेल में एक फ़ॉर्मूला रखेंगे जो दो काम करेगा:

1. **छह संख्याओं का सीक्वेंस एरे** जेनरेट करना (`SEQUENCE(6)` → 1,2,3,4,5,6)।  
2. उन संख्याओं को **दो कॉलम में रैप** करना (`WRAPCOLS(..., 2)`)।

```csharp
            // Write the WRAPCOLS formula into A1
            worksheet.Cell("A1").FormulaA1 = "=WRAPCOLS(SEQUENCE(6), 2)";

            // --------------------------------------------------------------
            // Finally, force the engine to evaluate the formula
            // --------------------------------------------------------------
```

> **क्या हो रहा है?**  
> `SEQUENCE(6)` एक वर्टिकल एरे `{1;2;3;4;5;6}` बनाता है। `WRAPCOLS` फिर उस एरे को निर्दिष्ट कॉलम संख्या में “रैप” करता है—इस केस में **2**। परिणामस्वरूप 3‑रो × 2‑कॉलम ब्लॉक इस प्रकार दिखता है:

| A | B |
|---|---|
| 1 | 4 |
| 2 | 5 |
| 3 | 6 |

यदि आप दूसरे आर्ग्यूमेंट को **3** बदलते हैं, तो आपको तीन‑कॉलम लेआउट मिलेगा। यही **डायनामिक रूप से कॉलम कैसे बनाएं** का मूल सिद्धांत है बिना मैन्युअल लूप के।

## चरण 3: वर्कशीट को पुनः गणना करें (फ़ॉर्मूला के मूल्यांकन को सुनिश्चित करना)

ClosedXML लिखते समय फ़ॉर्मूला को स्वतः मूल्यांकन नहीं करता। आपको वर्कबुक (या विशिष्ट वर्कशीट) पर `Calculate()` कॉल करना होगा ताकि मूल्यांकन बाध्य हो।

```csharp
            // Recalculate so the formula is evaluated immediately
            worksheet.Calculate();

            // Optional: save the workbook to inspect the result
            workbook.SaveAs("WrapColsDemo.xlsx");
        }
    }
}
```

> **प्रो टिप:** यदि आप बड़े वर्कबुक के साथ काम कर रहे हैं, तो केवल उन शीट्स पर `Calculate()` कॉल करें जिनमें बदलाव हुआ है। इससे मेमोरी बचती है और प्रोसेसिंग तेज़ होती है।

जब आप `WrapColsDemo.xlsx` खोलेंगे तो **A1:B3** में दो‑कॉलम लेआउट साफ़-साफ़ भराव देखेंगे। पंक्तियों या कॉलमों के माध्यम से लूप करने के लिए कोई अतिरिक्त कोड नहीं चाहिए था – `WRAPCOLS` ने सब संभाल लिया।

## चरण 4: आउटपुट की जाँच करें (क्या अपेक्षित है)

प्रोग्राम चलाने के बाद, जेनरेट की गई फ़ाइल खोलें। आपको यह दिखना चाहिए:

| A | B |
|---|---|
| 1 | 4 |
| 2 | 5 |
| 3 | 6 |

यदि संख्याएँ वर्टिकली (यानी सभी कॉलम A में) दिख रही हैं, तो सुनिश्चित करें कि आपने फ़ॉर्मूला सेट करने के **बाद** `worksheet.Calculate()` कॉल किया है। कुछ इंजनों को `workbook.Calculate()` भी चाहिए; ऊपर दिया गया स्निपेट ClosedXML के बिल्ट‑इन इवैल्युएटर के लिए काम करता है।

## सामान्य विविधताएँ और एज केस

### कॉलम संख्या बदलना

विभिन्न पंक्ति संख्या के साथ **दो‑कॉलम लेआउट** बनाने के लिए, बस `SEQUENCE` का आकार या `WRAPCOLS` के दूसरे आर्ग्यूमेंट को बदलें:

```csharp
worksheet.Cell("A1").FormulaA1 = "=WRAPCOLS(SEQUENCE(12), 3)";
```

यह 4‑रो × 3‑कॉलम ब्लॉक बनाता है (12 संख्याएँ तीन कॉलम में विभाजित)।

### डायनामिक कॉलम काउंट का उपयोग

यदि आपका कॉलम काउंट किसी वेरिएबल से आता है, तो उसे स्ट्रिंग इंटरपोलेशन के साथ एम्बेड करें:

```csharp
int colCount = 4;
worksheet.Cell("A1").FormulaA1 = $"=WRAPCOLS(SEQUENCE(8), {colCount})";
```

अब आपके पास **फ़ॉर्मूला कैसे जोड़ें** है जो रनटाइम पर अनुकूलित होता है।

### खाली वर्कशीट्स

यदि वर्कशीट खाली है, तो भी `Calculate()` काम करता है – फ़ॉर्मूला A1 से शुरू होकर सेल्स भर देगा। हालांकि, यदि आप बाद में उन पंक्तियों/कॉलमों को डिलीट करते हैं जो आउटपुट रेंज के साथ ओवरलैप होते हैं, तो आपको `#REF!` एरर मिल सकता है। इसे रोकने के लिए पहले टार्गेट रेंज को क्लियर करें:

```csharp
worksheet.Range("A1:Z100").Clear(); // wipes any leftovers
```

### संगतता

`WRAPCOLS` और `SEQUENCE` Excel के **डायनामिक एरे** फ़ंक्शन्स का हिस्सा हैं, जो Office 365 में पेश किए गए थे। यदि आप पुराने Excel संस्करण को टार्गेट करते हैं, तो ये फ़ंक्शन मौजूद नहीं होंगे और आपको मैन्युअल लूप की जरूरत पड़ेगी। ClosedXML का इवैल्युएटर नवीनतम Excel व्यवहार को प्रतिबिंबित करता है, इसलिए यह आधुनिक वातावरण के लिए सुरक्षित है।

## पूर्ण कार्यशील उदाहरण (कॉपी‑पेस्ट तैयार)

```csharp
using ClosedXML.Excel;

namespace WrapColsDemo
{
    class Program
    {
        static void Main()
        {
            // 1️⃣ Create workbook & worksheet
            using var workbook = new XLWorkbook();
            var ws = workbook.Worksheets.Add("Demo");
            var worksheet = ws;   // clearer name

            // 2️⃣ Write WRAPCOLS formula that generates a sequence array
            worksheet.Cell("A1").FormulaA1 = "=WRAPCOLS(SEQUENCE(6), 2)";

            // 3️⃣ Force calculation so the formula resolves immediately
            worksheet.Calculate();

            // 4️⃣ Save the file (optional, but handy for verification)
            workbook.SaveAs("WrapColsDemo.xlsx");
        }
    }
}
```

**अपेक्षित परिणाम:** *WrapColsDemo.xlsx* खोलने पर एक साफ़ दो‑कॉलम लेआउट दिखेगा जिसमें 1‑6 संख्याएँ पहले वर्णित क्रम में व्यवस्थित होंगी।

## निष्कर्ष

हमने **WRAPCOLS का उपयोग कैसे करें** करके **दो‑कॉलम लेआउट बनाना** कवर किया, प्रोग्रामेटिक रूप से **फ़ॉर्मूला कैसे जोड़ें** दिखाया, और देखा कि `SEQUENCE` आपको **सीक्वेंस एरे जेनरेट** करने की सुविधा बिना लूप के देता है। C# से Excel के डायनामिक एरे फ़ंक्शन्स को उपयोग करके आप अपना कोड संक्षिप्त, पठनीय और मेंटेनेबल रख सकते हैं।

आगे, आप खोज सकते हैं:

- `ROWS` या `COUNTA` के साथ डायनामिक रो काउंट बनाना।  
- आउटपुट को स्टाइल करना (बॉर्डर, नंबर फ़ॉर्मेट) ClosedXML की स्टाइलिंग API का उपयोग करके।  
- लेआउट बन जाने के बाद CSV में एक्सपोर्ट करना, ताकि आगे की प्रोसेसिंग हो सके।  

इसे आज़माएँ, कॉलम काउंट को बदलें, और देखें कि आप कितनी जल्दी जटिल स्प्रेडशीट्स का प्रोटोटाइप बना सकते हैं। कोडिंग का आनंद लें!

{{< /blocks/products/pf/tutorial-page-section >}}
{{< /blocks/products/pf/main-container >}}
{{< /blocks/products/pf/main-wrap-class >}}
{{< blocks/products/products-backtop-button >}}